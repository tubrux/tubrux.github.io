---
layout: default
---

<!-- Text can be **bold**, _italic_, or ~~strikethrough~~.

[Link to another page](./another-page.html).

There should be whitespace between paragraphs.

There should be whitespace between paragraphs. We recommend including a README, or a file with information about your project.

# Header 1

This is a normal paragraph following a header. GitHub is a code hosting platform for version control and collaboration. It lets you and others work together on projects from anywhere.

## Header 2

> This is a blockquote following a header.
>
> When something is important enough, you do it even if the odds are not in your favor.

### Header 3 -->
<!-- <img width="100%" src="https://github.com/tubruxjvm/tubruxjvm.github.io/blob/main/log.png?raw=true"/> -->

**Tubrux** is an innovative library crafted to proactively detect and address potential thread-safety and other issues in Java and Kotlin classes.

With **Tubrux**, we can effortlessly identify non-thread-safe data structures that may jeopardize your application's stability in multi-threaded environments. Beyond that, it offers seamless deadlock detection, ensuring smooth and reliable performance during runtime. Elevate your code's safety and reliability with **Tubrux**’s smart, automated solutions.


<!-- Features
--------

* *Unsafe-thread Data Structure Detection*

  tubrux can identify commonly Unsafe-thread Data Structure in multi-threaded contexts, such as `ArrayList`, `HashMap`, and `StringBuilder`.

* *Thread-safe Alternatives Recommendation*

  This feature suggests safer alternatives to replace unsafe collections or objects, enhancing the application's thread safety.

* *Deadlock Detection*

  tubrux automatically detects deadlocks in the system and provides detailed information on locked threads.

Why do we need a tubrux
------------------------

* *Early Problem Detection*

  tubrux proactively identifies unsafe data collections for multi-threading operations, helping to avoid unpredictable program behavior due to thread safety issues.

* *Improved Code Quality*

  By using tubrux, you can enhance code quality, making it more stable, reliable, and maintainable.

* *Development Efficiency*

  tubrux saves time by automatically detecting issues, allowing developers to focus on business logic instead of debugging concurrency problems.

* *Ease of Use*

  - *Easy Integration*

    tubrux can be easily integrated into your project by adding it to the project dependencies.

  - *Clear Reporting*

    The reports generated by tubrux are easy to understand, even for developers not deeply familiar with concurrency concepts. -->

<!-- Note: **This is not to guarantee thread safety. It just helps reduce potential thread safety issues**. -->


## Installation
### In Gradle

```groovy
repositories {
    maven { url 'https://repo.repsy.io/mvn/hangga/repo' }
}

dependencies {
    implementation 'io.tubrux:tubrux:0.0.2'
}
```
### In Maven
```xml
<repositories>
    <repository>
        <id>tubrux-repo</id>
        <url>https://repo.repsy.io/mvn/hangga/repo</url>
    </repository>
</repositories>

<dependencies>
    <dependency>
        <groupId>io.tubrux</groupId>
        <artifactId>tubrux</artifactId>
        <version>0.0.2</version>
    </dependency>
</dependencies>
```

## Basic Usage
To start the **Tubrux** analysis, simply create an instance of **Tubrux** and call `scan()` on it:
### In Java
```java
new Tubrux()
    .setShowDate(true)
    .setDetectSensitiveData(true)
    .scan();
```
### In Kotlin
```java
Tubrux()
    .setShowDate(true)
    .setDetectSensitiveData(true)
    .scan()
```

## Sample Report

The output from the analysis will show detailed reports about the potential vulnerabilities detected in your code. Here’s an example of what the output might look like:

 <img width="100%" src="https://raw.githubusercontent.com/tubrux/tubrux.github.io/refs/heads/tubrux/log-tubrux.webp"/>

## How Tubrux Works: A Hybrid Approach to Vulnerability Analysis

**Tubrux** is a **runtime-assisted static analysis tool** designed to detect potential vulnerabilities in Java and Kotlin codebases. Unlike traditional Static Application Security Testing (SAST) tools, which perform code analysis without execution, Tubrux requires the code to be run in a runtime environment—either within the main application or a unit test. The tool works by first gathering the source code from the project, including files like `.java`, `.kt`,`.gradle` and `.xml`. Once executed, Tubrux analyzes the code, looking for issues such as thread-safety violations, deadlocks, and sensitive data exposure. This execution phase allows Tubrux to incorporate runtime context into its analysis, making it a **hybrid analyzer** rather than a pure static analysis tool. By combining static code reading with runtime behavior, Tubrux is able to detect a broader range of vulnerabilities, particularly those that only manifest during code execution, thus offering more comprehensive vulnerability detection than traditional SAST tools.

Here’s the flow diagram of **Tubrux**'s process in text format, describing its operation as a **runtime-assisted static analysis tool** or **hybrid analyzer**:

```html
+----------------------------------------+
|  Start: Project Code Base              |
+----------------------------------------+
                   |
                   v
+----------------------------------------+
|  Step 1: Gather Source                 |
|  Code Files (.java, .kt, .gradle, ...) |
+----------------------------------------+
                   |
                   v
+----------------------------------------+
|  Step 2: Run Tubrux                    |
|  (Executed in Main App or Unit Test)   |
+----------------------------------------+
                   |
                   v
+----------------------------------------+
|  Step 3: Analyze Code                  |
|  (Hybrid: Static & Runtime)            |
+----------------------------------------+
                   |
                   v
+----------------------------------------+
|  Step 4: Identify Issues               |
|  (e.g., thread-safety, deadlocks,      |
|   sensitive data)                      |
+----------------------------------------+
                   |
                   v
+----------------------------------------+
|  Step 5: Report Findings               |
|  (Vulnerability Report)                |
+----------------------------------------+
                   |
                   v
+----------------------------------------+
|                 End                    |
+----------------------------------------+


```

1. **Start**: The process begins with gathering the **source code files** from the project (e.g., `.java`, `.kt`, `.gradle`).
2. **Step 1**: Tubrux collects code from various files for analysis.
3. **Step 2**: **Tubrux is executed**, either in the main application or within a unit test, to start the execution and analysis.
4. **Step 3**: At this stage, **Tubrux analyzes the code**, combining static code inspection with runtime information gathered during execution.
5. **Step 4**: **Issues are detected**, such as **thread-safety** violations, **deadlocks**, and **sensitive data exposure**.
6. **Step 5**: The analysis results are **reported**, generating a vulnerability report that highlights potential problems in the code.
7. **End**: The process concludes with the report providing valuable insights for fixing vulnerabilities.

With this workflow, Tubrux is classified as a **runtime-assisted static analysis tool** or **hybrid analyzer**, as it requires code execution to complete its analysis, blending both static and dynamic aspects for vulnerability detection.

## Attention, please

It is important to note that this library is very useful for the development stage. But because tubrux works by checking each line of code, it is **not recommended for the production stage**.
<!-- 
<a target="_blank" href="https://github.com/tubrux/example" class="paypal-button">Complete Example</a> -->

<!-- ## Example Test Class
The following example demonstrates how to structure a test class to check for thread safety issues using the tubrux library. This class simulates potential deadlocks and thread-unsafe scenarios, which are detected and analyzed by tubrux.

```Java
package io.tubrux

import org.junit.jupiter.api.Test
import java.lang.Thread.sleep
import kotlin.concurrent.thread

class Account(val name: String, var balance: Int) {

    private fun deposit(amount: Int) {
        balance += amount
    }

    private fun withdraw(amount: Int) {
        balance -= amount
    }

    fun transfer(to: Account, amount: Int) {
        println("${this.name} tries to transfer $amount to ${to.name}.")
        synchronized(this) {
            sleep(10) // Simulate processing time
            if (balance >= amount) {
                withdraw(amount)
                synchronized(to) {
                    to.deposit(amount)
                }
            }
        }
    }
}

@TubruxRun(showDate = true, detectDeadlock = true)
class tubruxExampleKotlinUnitTest {

    @Test
    fun `example of deadlock`() {
        val account1 = Account("Hangga", 1000)
        val account2 = Account("John", 1000)
        val account3 = Account("Alice", 2000)

        // Transfer from account1 to account2
        thread {
            account1.transfer(account2, 100)
        }.join(10) // as a simulation of the time required

        // Transfer from account2 to account1
        thread {
            account2.transfer(account1, 200)
        }.join(20)

        // Transfer from account3 to account1
        thread {
            account3.transfer(account1, 1000)
        }.join(500)

        tubrux(this).start()
    }

    val list = ArrayList()

    @Test
    fun `example thread-unsafe using HashMap`() {
        val map = HashMap()

        val threads = List(10) { index ->
            thread {
                for (i in 0 until 1000) {
                    map[i] = index
                }
            }
        }

        threads.forEach {
            it.join()
        }
    }
}
``` -->

<!-- ## About

The name **Tubrux** is inspired by the Indonesian words "Man = Aman" (safe) and "Dali = terkenDali" (controlled), symbolizing **safety under control**.  -->

## License

**Tubrux** is a proprietary, closed-source library with restrictions on redistribution and modification.

It is free to use, but if you find it valuable, you are welcome to make a donation or become a sponsor. For more information, please contact our development team.