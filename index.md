---
layout: default
---

<!-- Text can be **bold**, _italic_, or ~~strikethrough~~.

[Link to another page](./another-page.html).

There should be whitespace between paragraphs.

There should be whitespace between paragraphs. We recommend including a README, or a file with information about your project.

# Header 1

This is a normal paragraph following a header. GitHub is a code hosting platform for version control and collaboration. It lets you and others work together on projects from anywhere.

## Header 2

> This is a blockquote following a header.
>
> When something is important enough, you do it even if the odds are not in your favor.

### Header 3 -->
<!-- <img width="100%" src="https://github.com/tubruxjvm/tubruxjvm.github.io/blob/main/log.png?raw=true"/> -->

**Tubrux** is an innovative library crafted to proactively detect and address potential thread-safety and other issues in Java and Kotlin classes.

With **Tubrux**, we can effortlessly identify non-thread-safe data structures that may jeopardize your application's stability in multi-threaded environments. Beyond that, it offers seamless deadlock detection, ensuring smooth and reliable performance during runtime. Elevate your code's safety and reliability with **Tubrux**’s smart, automated solutions.


<!-- Features
--------

* *Unsafe-thread Data Structure Detection*

  tubrux can identify commonly Unsafe-thread Data Structure in multi-threaded contexts, such as `ArrayList`, `HashMap`, and `StringBuilder`.

* *Thread-safe Alternatives Recommendation*

  This feature suggests safer alternatives to replace unsafe collections or objects, enhancing the application's thread safety.

* *Deadlock Detection*

  tubrux automatically detects deadlocks in the system and provides detailed information on locked threads.

Why do we need a tubrux
------------------------

* *Early Problem Detection*

  tubrux proactively identifies unsafe data collections for multi-threading operations, helping to avoid unpredictable program behavior due to thread safety issues.

* *Improved Code Quality*

  By using tubrux, you can enhance code quality, making it more stable, reliable, and maintainable.

* *Development Efficiency*

  tubrux saves time by automatically detecting issues, allowing developers to focus on business logic instead of debugging concurrency problems.

* *Ease of Use*

  - *Easy Integration*

    tubrux can be easily integrated into your project by adding it to the project dependencies.

  - *Clear Reporting*

    The reports generated by tubrux are easy to understand, even for developers not deeply familiar with concurrency concepts. -->

<!-- Note: **This is not to guarantee thread safety. It just helps reduce potential thread safety issues**. -->


## Installation
### In Gradle

```groovy
repositories {
    maven { url 'https://repo.repsy.io/mvn/hangga/repo' }
}

dependencies {
    implementation 'io.tubrux:tubrux:0.0.2'
}
```
### In Maven
```xml
<repositories>
    <repository>
        <id>tubrux-repo</id>
        <url>https://repo.repsy.io/mvn/hangga/repo</url>
    </repository>
</repositories>

<dependencies>
    <dependency>
        <groupId>io.tubrux</groupId>
        <artifactId>tubrux</artifactId>
        <version>0.0.2</version>
    </dependency>
</dependencies>
```

## Basic Usage
To start the **Tubrux** analysis, simply create an instance of **Tubrux** and call `scan()` on it:
### In Java
```java
new Tubrux()
    .setShowDate(true)
    .setDetectSensitiveData(true)
    .scan();
```
### In Kotlin
```java
Tubrux()
    .setShowDate(true)
    .setDetectSensitiveData(true)
    .scan()
```

## Sample Report

The output from the analysis will show detailed reports about the potential vulnerabilities detected in your code. Here’s an example of what the output might look like:

 <img width="100%" src="https://raw.githubusercontent.com/tubrux/tubrux.github.io/refs/heads/tubrux/log-tubrux.webp"/>

## Attention, please

It is important to note that this library is very useful for the development stage. But because tubrux works by checking each line of code, it is **not recommended for the production stage**.

## <a href="https://tubrux.github.io/blog/2024/10/01/how-tubrux-works.html">Read Post : How Tubrux Works >></a>
<!-- 
<a target="_blank" href="https://github.com/tubrux/example" class="paypal-button">Complete Example</a> -->

<!-- ## Example Test Class
The following example demonstrates how to structure a test class to check for thread safety issues using the tubrux library. This class simulates potential deadlocks and thread-unsafe scenarios, which are detected and analyzed by tubrux.

```Java
package io.tubrux

import org.junit.jupiter.api.Test
import java.lang.Thread.sleep
import kotlin.concurrent.thread

class Account(val name: String, var balance: Int) {

    private fun deposit(amount: Int) {
        balance += amount
    }

    private fun withdraw(amount: Int) {
        balance -= amount
    }

    fun transfer(to: Account, amount: Int) {
        println("${this.name} tries to transfer $amount to ${to.name}.")
        synchronized(this) {
            sleep(10) // Simulate processing time
            if (balance >= amount) {
                withdraw(amount)
                synchronized(to) {
                    to.deposit(amount)
                }
            }
        }
    }
}

@TubruxRun(showDate = true, detectDeadlock = true)
class tubruxExampleKotlinUnitTest {

    @Test
    fun `example of deadlock`() {
        val account1 = Account("Hangga", 1000)
        val account2 = Account("John", 1000)
        val account3 = Account("Alice", 2000)

        // Transfer from account1 to account2
        thread {
            account1.transfer(account2, 100)
        }.join(10) // as a simulation of the time required

        // Transfer from account2 to account1
        thread {
            account2.transfer(account1, 200)
        }.join(20)

        // Transfer from account3 to account1
        thread {
            account3.transfer(account1, 1000)
        }.join(500)

        tubrux(this).start()
    }

    val list = ArrayList()

    @Test
    fun `example thread-unsafe using HashMap`() {
        val map = HashMap()

        val threads = List(10) { index ->
            thread {
                for (i in 0 until 1000) {
                    map[i] = index
                }
            }
        }

        threads.forEach {
            it.join()
        }
    }
}
``` -->

<!-- ## About

The name **Tubrux** is inspired by the Indonesian words "Man = Aman" (safe) and "Dali = terkenDali" (controlled), symbolizing **safety under control**.  -->

## License

**Tubrux** is a proprietary, closed-source library with restrictions on redistribution and modification.

It is free to use, but if you find it valuable, you are welcome to make a donation or become a sponsor. For more information, please contact our development team.